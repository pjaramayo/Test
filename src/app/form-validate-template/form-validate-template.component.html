<form>
<label for="modelIput">Test de Ng Model</label>
  <input #modelInput [ngModel]="model" (ngModelChange)="cambiarValor($event)">
  <p>Valor del model-> : </p>
  <p>{{model}}</p>
  <p>{{donBool}}</p>

  <label class="col-form-label" for="name">Name: </label>
  <input type="text" id="name" name="name" class="form-control" required minlength="4" appForbiddenName="Ramon"
  [(ngModel)]="actor.name"  #ame="ngModel"/>
  <p>{{actor.name}}</p>


  @if (ame.invalid && (ame.dirty || ame.touched)) {
     touched {{ame.touched}}
  <div class="alert">
    @if (ame.hasError('required')) {
    <div>adfa
      Campo name requerido.
    </div>
    }
    @if (ame.hasError('minlength')) {
    <div>
      Name necesita ser mas de 4 caracteres.
    </div>
    }
    @if (ame.hasError('forbiddenName')) {
    <div>
      No se acepta a {{ame.value}}

    </div>
    }
  </div>
  }
</form>








<div class="container">
  <ul>
    <h1>Conceptos Fundamentales de ValidaciÃ³n en Angular.</h1>
    <h6>Nivel 2(comprender)</h6>


    <h2>1. Â¿QuÃ© es <code>NG_VALIDATORS</code>?</h2>
    <li>
      <p>Es un <strong>ðŸ”‘token de ðŸ’‰inyecciÃ³n de ðŸ“¦dependencias de Angular</strong> (ðŸ†” una identificaciÃ³n).
    </li>


    <h2>2. Â¿CuÃ¡l es la funciÃ³n del TOKEN <code>NG_VALIDATORS</code>?</h2>
    <li>Angular por medio de esta, <b>agrupa y reconoce</b> ðŸ“¤proveedores de validadores personalizados en sus
      formularios.</li>
    <li>
      <p>La funciÃ³n principal de este ðŸ”‘token es <strong>ðŸ“¤proveer una identificaciÃ³n a Angular</strong> para que sepa
        que se
        van a ðŸ’‰inyectar validadores como:</p>
    </li>
    <ul class="lista-sin-vinetas">
      <li><code>âœ… Validator</code></li>
      <li><code>âœ… ValidatorFn</code></li>
      <li><code>âœ… ValidatorErrors</code></li>
    </ul>
    <li>
      <p>Estos validadores se aplican a los <b>elementos de entrada (input)</b> de la vista, permitiendo que los
        formularios
        de Angular realicen validaciones complejas y personalizadas.</p>
    </li>



    <h2>3. Â¿QuÃ© es <code>Validator</code>?</h2>
    <li>
      <p><code>Validator</code> es una <strong><span class="realtado" title="- La encargada de definir un **modelo de objetos** con los tipos de datos **explÃ­citamente**.

    ðŸ”¹ **En TypeScript, la interfaz define la estructura de un objeto.**

- âŒ [Pero no define su implementaciÃ³n.]">interfaz</span></strong> que se implementa sobre <strong><span
            title="- DefiniciÃ³n de clase.
    - Es una plantilla o un molde dispone de **propiedades** y **mÃ©todos** como toda `clase` o sea una clase dispone un:
        - Estado:
            - Cuando se escribe o crea una clase son propiedades, pero cuando al instanciar en ese momento ya tiene un estado, pasan a ser atributos.
        - Comportamiento:
            - Cuando se las escribe o crea son mÃ©todos, pero al instanciar y utilizar este pasan a tener un comportamiento, para interactuar con otro objeto.">clase</span></strong>
        para crear una
        <strong>directiva de validador</strong> con un error personalizado. Esto es Ãºtil cuando necesitas una lÃ³gica de
        validaciÃ³n mÃ¡s compleja o reutilizable a travÃ©s de una directiva.
      </p>
    </li>
    <p><strong>Ejemplo de implementaciÃ³n:</strong></p>
    <pre><code>export class ForbiddenValidatorDirective ðŸ‘‰â€‹implements Validator &lbrace;
  validate(control: AbstractControl): &lbrace; [key: string]: any &rbrace; | null &lbrace;
    // LÃ³gica de validaciÃ³n
    return &lbrace;'forbiddenName': true&rbrace;; // Retorna un error si es invÃ¡lido
  &rbrace;
&rbrace;</code></pre>



    <h2>4. Â¿Para quÃ© se implementa <code>Validator</code> en una clase?</h2>
    <li>
      <p>Se implementa para realizar un <strong>control o inspecciÃ³n personalizado</strong> a un elemento de entrada
        (input)
        del formulario (<code>frm</code>) por medio de su mÃ©todo <code>validate</code>.</p>
    </li>
    <p>El mÃ©todo <code>validate</code> recibe un <code>AbstractControl</code> (que representa el elemento de entrada del
      formulario) y debe devolver:</p>
    <ul>
      <li>Un objeto de tipo <code>ValidatorErrors</code> (por ejemplo, <code>&lbrace;'customError': true&rbrace;</code>)
        si el valor es <strong>invÃ¡lido</strong>.</li>
      <li><code>null</code> si el valor es <strong>vÃ¡lido</strong>.</li>
    </ul>
    <p><strong>Sintaxis del mÃ©todo <code>validate</code>:</strong></p>
    <pre><code>validate(control: AbstractControl): ValidatorErrors | null &lbrace;
  // ... lÃ³gica de validaciÃ³n ...
  return &lbrace;'custom': true&rbrace;; // Ejemplo: 'custom' es la clave del error
&rbrace;</code></pre>
    <p>Donde:</p>
    <ul>
      <li><code>AbstractControl</code>: Es el elemento de entrada (input) del formulario.</li>
      <li><code>ValidatorErrors</code>: Significa que el valor es **invÃ¡lido**.</li>
      <li><code>null</code>: Significa que el valor es **vÃ¡lido**.</li>
    </ul>



    <h2>5. Â¿QuÃ© es <code>ValidatorFn</code>?</h2>
    <li>
      <p><code>ValidatorFn</code> es una <strong>interfaz</strong> que se aplica a una <strong>funciÃ³n
          validadora</strong>.
        Permite crear una funciÃ³n de validaciÃ³n para un elemento de entrada (input) <strong>sin necesidad de crear una
          clase
          o directiva</strong>. Es ideal para validaciones mÃ¡s sencillas y directas.</p>
    </li>


    <h2>6. Â¿Para quÃ© se implementa un <code>ValidatorFn</code>?</h2>
    <li>
      <p>Se implementa para que la funciÃ³n validadora <strong>reciba un elemento de entrada
          (<code>como un FormControl, FormGroup, etc.</code>)</strong>
        y devuelva un diagnÃ³stico. Al igual que con <code>Validator</code>, la funciÃ³n debe retornar:</p>
    </li>
    <ul>
      <li>Un objeto de tipo <code>ValidatorErrors</code> si el valor es <strong>invÃ¡lido</strong>.</li>
      <li><code>null</code> si el valor es <strong>vÃ¡lido</strong>.</li>
    </ul>
    <p><strong>Sintaxis de una <code>ValidatorFn</code>:</strong></p>
    <pre><code>function forbiddenNameValidator(nameRe: RegExp): ValidatorFn &lbrace;
  return (control: AbstractControl): ValidatorErrors | null => &lbrace;
    const forbidden = nameRe.test(control.value);
    return forbidden ? &lbrace;'forbiddenName': &lbrace;value: control.value&rbrace;&rbrace; : null;
  &rbrace;;
&rbrace;</code></pre>
    <p>Donde:</p>
    <ul>
      <li><code>AbstractControl</code>: Es el elemento de entrada (input) del formulario.</li>
      <li><code>ValidatorErrors</code>: Significa que el valor es <strong>invÃ¡lido</strong>.
        Este recibe una clave y un valor
      </li>

      <li><code>null</code>: Significa que el valor es <strong>vÃ¡lido.</strong> </li>
    </ul>
    <p>La funciÃ³n retornarÃ¡ <code>true</code> o <code>false</code> (o un objeto de error/<code>null</code>) por medio de
      una prueba (<code>test</code>) que compara el <code>control</code> (input - <code>AbstractControl</code>) contra
      un
      valor o patrÃ³n definido por parÃ¡metro.</p>
  </ul>
</div>
